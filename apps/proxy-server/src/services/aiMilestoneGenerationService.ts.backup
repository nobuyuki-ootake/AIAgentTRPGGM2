import { Database } from 'better-sqlite3';
import { randomUUID } from 'crypto';
import { 
  AIMilestone, 
  EntityPool, 
  EntityPoolCollection,
  MilestoneGenerationRequest,
  MilestoneGenerationResponse,
  ThemeAdaptation,
  SessionDurationConfig,
  ID,
  PoolEnemy,
  InteractiveEvent,
  PoolNPC,
  PoolItem,
  PoolQuest,
  MilestoneType
} from '@ai-agent-trpg/types';
import { getDatabase } from '../database/database';
import { logger } from '../utils/logger';
import { AIServiceError } from '../middleware/errorHandler';
import { getAIService } from './aiService';


export class AIMilestoneGenerationService {
  private db: Database;

  constructor() {
    this.db = getDatabase();
    this.initTables();
  }

  private initTables(): void {
    // AI マイルストーンテーブル
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS ai_milestones (
        id TEXT PRIMARY KEY,
        campaign_id TEXT NOT NULL,
        session_id TEXT NOT NULL,
        title TEXT NOT NULL,
        description TEXT NOT NULL,
        type TEXT NOT NULL,
        target_id TEXT NOT NULL,
        target_details TEXT NOT NULL,
        status TEXT NOT NULL DEFAULT 'pending',
        progress INTEGER NOT NULL DEFAULT 0,
        required_conditions TEXT NOT NULL DEFAULT '[]',
        reward TEXT NOT NULL DEFAULT '{}',
        created_at TEXT NOT NULL,
        completed_at TEXT,
        FOREIGN KEY (campaign_id) REFERENCES campaigns(id) ON DELETE CASCADE
      )
    `);

    // エンティティプールテーブル
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS entity_pools (
        id TEXT PRIMARY KEY,
        campaign_id TEXT NOT NULL,
        session_id TEXT NOT NULL,
        theme_id TEXT NOT NULL,
        entities TEXT NOT NULL,
        generated_at TEXT NOT NULL,
        last_updated TEXT NOT NULL,
        FOREIGN KEY (campaign_id) REFERENCES campaigns(id) ON DELETE CASCADE
      )
    `);

    // テーマ適応テーブル
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS theme_adaptations (
        id TEXT PRIMARY KEY,
        theme_id TEXT NOT NULL,
        allowed_entity_types TEXT NOT NULL,
        restricted_entity_types TEXT NOT NULL,
        specializations TEXT NOT NULL,
        content_modifiers TEXT NOT NULL,
        created_at TEXT NOT NULL
      )
    `);

    // マイルストーン生成履歴テーブル
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS milestone_generation_history (
        id TEXT PRIMARY KEY,
        campaign_id TEXT NOT NULL,
        session_id TEXT NOT NULL,
        generation_metadata TEXT NOT NULL,
        generated_at TEXT NOT NULL,
        FOREIGN KEY (campaign_id) REFERENCES campaigns(id) ON DELETE CASCADE
      )
    `);
  }

  /**
   * セッション開始時のマイルストーン・プール生成（トップダウンアプローチ）
   */
  async generateMilestonesAndPools(request: MilestoneGenerationRequest): Promise<MilestoneGenerationResponse> {
    const startTime = Date.now();
    
    try {
      logger.info('🎯 AI マイルストーン生成開始（トップダウン）', { 
        campaignId: request.campaignId,
        sessionId: request.sessionId,
        milestoneCount: request.milestoneCount 
      });

      // Phase 1: 目標設計
      logger.info('📋 Phase 1: 目標設計開始');
      const themeAdaptation = await this.generateThemeAdaptation(request.themeId, request.sessionDuration);
      const milestoneOutlines = await this.generateMilestoneOutlines(request, themeAdaptation);
      const milestoneRelations = await this.defineMilestoneRelations(milestoneOutlines);
      
      // Phase 2: コンテンツ生成
      logger.info('🎲 Phase 2: コンテンツ生成開始');
      const coreEntityRequirements = await this.defineCoreEntityRequirements(milestoneRelations, themeAdaptation);
      const coreEntities = await this.generateCoreEntities(coreEntityRequirements, request, themeAdaptation);
      const bonusEntities = await this.generateBonusEntities(request, coreEntities);
      const _locationMappings = await this.generateLocationMappings(coreEntities, bonusEntities);
      
      // Phase 3: 最終調整
      logger.info('⚖️ Phase 3: 最終調整開始');
      const detailedMilestones = await this.detailizeMilestones(milestoneOutlines, coreEntities);
      const balancedSystem = await this.balanceSystem(detailedMilestones, coreEntities, bonusEntities);
      
      // 一括データベースコミット
      const commitResult = await this.commitToDatabase(balancedSystem);

      const processingTime = Date.now() - startTime;
      
      const response: MilestoneGenerationResponse = {
        milestones: commitResult.milestones,
        entityPool: commitResult.entityPool,
        themeAdaptation: commitResult.themeAdaptation,
        generationMetadata: {
          model: 'gemini-2.0-flash-lite', // 現在使用中のモデル
          prompt: 'AI milestone top-down generation', 
          tokensUsed: 0, // TODO: トークン使用量を記録
          processingTime,
          generatedAt: new Date().toISOString()
        }
      };

      // 生成履歴を保存
      try {
        await this.saveGenerationHistory(request, response);
        logger.debug('✅ 生成履歴保存完了');
      } catch (historyError) {
        logger.warn('⚠️ 生成履歴保存に失敗しましたが、メインの生成処理は成功しました', { 
          error: historyError 
        });
      }

      logger.info('✅ AI マイルストーン生成完了（トップダウン）', { 
        milestonesCount: response.milestones.length,
        processingTime 
      });

      return response;

    } catch (error) {
      logger.error('❌ AI マイルストーン生成エラー', { error });
      throw new AIServiceError('Failed to generate milestones and pools', 'milestone-generation');
    }
  }

  /**
   * テーマ適応の生成
   */
  private async generateThemeAdaptation(themeId: ID, sessionConfig: SessionDurationConfig): Promise<ThemeAdaptation> {
    const aiService = getAIService();
    const provider = process.env.DEFAULT_AI_PROVIDER || 'google';
    
    try {
      const campaignContext = { themeId, sessionDuration: sessionConfig };
      
      const result = await aiService.performThemeAdaptation({
        provider,
        themeId,
        campaignContext,
        sessionDuration: sessionConfig,
      });

      // AI生成結果を解析
      const generatedAdaptation = result.generatedThemeAdaptation;
      
      if (generatedAdaptation && typeof generatedAdaptation === 'object' && !generatedAdaptation.rawData) {
        logger.info('✅ AI テーマ適応生成成功', { themeId, provider });
        return this.validateAndFormatThemeAdaptation(generatedAdaptation, themeId);
      }

      // AI生成に失敗した場合はフォールバック
      logger.warn('⚠️ AI テーマ適応生成失敗、フォールバック実行', { themeId });
      return this.createFallbackThemeAdaptation(themeId);

    } catch (error) {
      logger.error('❌ AI テーマ適応生成エラー', { error, themeId });
      return this.createFallbackThemeAdaptation(themeId);
    }
  }

  /**
   * フォールバックテーマ適応生成
   */
  private createFallbackThemeAdaptation(themeId: ID): ThemeAdaptation {
    const ispeacefulTheme = themeId.includes('peaceful') || themeId.includes('daily');
    
    return {
      themeId,
      allowedEntityTypes: ispeacefulTheme 
        ? ['event', 'npc', 'item', 'quest'] 
        : ['enemy', 'event', 'npc', 'item', 'quest'],
      restrictedEntityTypes: ispeacefulTheme ? ['enemy'] : [],
      specializations: [
        {
          entityType: 'event',
          categories: ispeacefulTheme ? ['daily_life', 'social', 'crafting'] : ['combat', 'exploration', 'mystery'],
          examples: ispeacefulTheme ? ['料理コンテスト', '地域祭り', '友人との会話'] : ['洞窟探索', '敵との遭遇', '謎解き'],
          generationHints: ispeacefulTheme ? ['平和的', '協力的', '創造的'] : ['挑戦的', '戦略的', '冒険的']
        }
      ],
      contentModifiers: [
        {
          type: 'tone',
          value: ispeacefulTheme ? 'peaceful' : 'adventurous',
          description: ispeacefulTheme ? '平和で穏やかな雰囲気' : '冒険的で挑戦的な雰囲気'
        }
      ]
    };
  }

  /**
   * AIで生成されたテーマ適応を検証・フォーマット
   */
  private validateAndFormatThemeAdaptation(aiThemeAdaptation: any, themeId: ID): ThemeAdaptation {
    logger.debug('🔧 AIテーマ適応データ変換開始', { 
      themeId,
      hasContentAdaptationStrategy: !!aiThemeAdaptation.contentAdaptationStrategy,
      hasContentModifiers: !!aiThemeAdaptation.contentModifiers,
      topLevelKeys: Object.keys(aiThemeAdaptation)
    });

    // AI応答から必要なフィールドを抽出
    const allowedEntityTypes = 
      aiThemeAdaptation.allowedEntityTypes ||
      aiThemeAdaptation.contentAdaptationStrategy?.allowedEntityTypes ||
      ['event', 'npc', 'item', 'quest'];

    const restrictedEntityTypes = 
      aiThemeAdaptation.restrictedEntityTypes ||
      aiThemeAdaptation.contentAdaptationStrategy?.restrictedEntityTypes ||
      [];

    const specializations = 
      aiThemeAdaptation.specializations ||
      aiThemeAdaptation.contentAdaptationStrategy?.specializations ||
      [{
        entityType: 'event',
        categories: ['mystery', 'horror'],
        examples: ['怪奇現象', '謎の発見'],
        generationHints: ['雰囲気重視', '緊張感']
      }];

    const contentModifiers = 
      aiThemeAdaptation.contentModifiers ||
      aiThemeAdaptation.contentAdaptationStrategy?.contentModifiers ||
      [{
        type: 'tone',
        value: 'mysterious',
        description: '神秘的で不安な雰囲気'
      }];

    const formattedThemeAdaptation: ThemeAdaptation = {
      themeId,
      allowedEntityTypes,
      restrictedEntityTypes,
      specializations,
      contentModifiers
    };

    logger.debug('✅ AIテーマ適応データ変換完了', {
      originalKeys: Object.keys(aiThemeAdaptation),
      formattedKeys: Object.keys(formattedThemeAdaptation),
      allowedEntityTypesCount: allowedEntityTypes.length,
      restrictedEntityTypesCount: restrictedEntityTypes.length,
      specializationsCount: specializations.length,
      contentModifiersCount: contentModifiers.length
    });

    return formattedThemeAdaptation;
  }

  /**
   * エンティティプールの生成
   */
  private async generateEntityPool(
    request: MilestoneGenerationRequest, 
    themeAdaptation: ThemeAdaptation
  ): Promise<EntityPool> {
    logger.debug('🎯 generateEntityPool 開始', { 
      campaignId: request.campaignId, 
      sessionId: request.sessionId,
      themeId: request.themeId 
    });
    
    const provider = process.env.DEFAULT_AI_PROVIDER || 'google';
    
    try {
      logger.debug('🔧 Getting AI service...');
      const aiService = getAIService();
      logger.debug('✅ AI service obtained');
      const poolId = randomUUID();
      const now = new Date().toISOString();
      
      logger.debug('🔧 Preparing campaign context...');
      const campaignContext = { 
        campaignId: request.campaignId,
        sessionId: request.sessionId,
        themeId: request.themeId,
        existingContent: request.existingContent 
      };
      logger.debug('✅ Campaign context prepared');

      // AIを使ってエンティティプールを生成
      logger.debug('🚀 AI エンティティプール生成開始', { provider, campaignId: request.campaignId });
      const result = await aiService.generateEntityPool({
        provider,
        campaignContext,
        themeAdaptation,
        sessionDuration: request.sessionDuration,
      });

      // AI生成結果を解析
      logger.debug('🔍 AI エンティティプール生成結果', { 
        resultKeys: Object.keys(result || {}),
        hasGeneratedPool: !!result?.generatedEntityPool,
        generatedPoolType: typeof result?.generatedEntityPool,
        generatedPoolKeys: result?.generatedEntityPool ? Object.keys(result.generatedEntityPool) : [],
        provider
      });
      
      const generatedPool = result.generatedEntityPool;
      
      if (generatedPool && typeof generatedPool === 'object' && !generatedPool.rawData) {
        logger.info('✅ AI エンティティプール生成成功', { 
          campaignId: request.campaignId,
          sessionId: request.sessionId,
          provider 
        });
        
        // 生成されたエンティティプールをラップ
        return {
          id: poolId,
          campaignId: request.campaignId,
          sessionId: request.sessionId,
          themeId: request.themeId,
          entities: generatedPool as EntityPoolCollection,
          generatedAt: now,
          lastUpdated: now
        };
      }

      // AI生成に失敗した場合はフォールバック
      logger.warn('⚠️ AI エンティティプール生成失敗、フォールバック実行', { 
        campaignId: request.campaignId 
      });
      return await this.createFallbackEntityPool(request, themeAdaptation);

    } catch (error) {
      logger.error('❌ AI エンティティプール生成エラー', { 
        error, 
        campaignId: request.campaignId,
        errorMessage: error instanceof Error ? error.message : 'Unknown error',
        errorStack: error instanceof Error ? error.stack : undefined,
        provider 
      });
      return await this.createFallbackEntityPool(request, themeAdaptation);
    }
  }

  /**
   * フォールバックエンティティプール生成
   */
  private async createFallbackEntityPool(
    request: MilestoneGenerationRequest, 
    themeAdaptation: ThemeAdaptation
  ): Promise<EntityPool> {
    const poolId = randomUUID();
    const now = new Date().toISOString();

    // テーマに基づいてエンティティを生成（フォールバック）
    const enemies = themeAdaptation.allowedEntityTypes.includes('enemy') 
      ? await this.generateEnemies(request, themeAdaptation) 
      : [];
    const events = await this.generateEvents(request, themeAdaptation);
    const npcs = await this.generateNPCs(request, themeAdaptation);
    const items = await this.generateItems(request, themeAdaptation);
    const quests = await this.generateQuests(request, themeAdaptation);

    const entities: EntityPoolCollection = {
      enemies,
      events,
      npcs,
      items,
      quests
    };

    return {
      id: poolId,
      campaignId: request.campaignId,
      sessionId: request.sessionId,
      themeId: request.themeId,
      entities,
      generatedAt: now,
      lastUpdated: now
    };
  }

  /**
   * マイルストーンの生成
   */
  private async generateMilestones(
    request: MilestoneGenerationRequest,
    entityPool: EntityPool,
    themeAdaptation: ThemeAdaptation
  ): Promise<AIMilestone[]> {
    const aiService = getAIService();
    const provider = process.env.DEFAULT_AI_PROVIDER || 'google';

    try {
      const campaignContext = { 
        campaignId: request.campaignId,
        sessionId: request.sessionId,
        themeId: request.themeId,
        existingContent: request.existingContent 
      };

      // AIを使ってマイルストーンを生成
      const result = await aiService.generateMilestones({
        provider,
        campaignContext,
        sessionDuration: request.sessionDuration,
        themeAdaptation,
        entityPool: entityPool.entities,
        milestoneCount: request.milestoneCount,
      });

      // AI生成結果を解析
      const generatedMilestones = result.generatedMilestones;
      
      if (generatedMilestones && Array.isArray(generatedMilestones)) {
        logger.info('✅ AI マイルストーン生成成功', { 
          campaignId: request.campaignId,
          sessionId: request.sessionId,
          milestonesCount: generatedMilestones.length,
          provider 
        });
        
        // AIで生成されたマイルストーンを正しい型に変換
        return generatedMilestones.map((milestone: any) => this.validateAndFormatMilestone(milestone, request));
      }

      // AI生成に失敗した場合はフォールバック
      logger.warn('⚠️ AI マイルストーン生成失敗、フォールバック実行', { 
        campaignId: request.campaignId 
      });
      return this.createFallbackMilestones(request, entityPool, themeAdaptation);

    } catch (error) {
      logger.error('❌ AI マイルストーン生成エラー', { error, campaignId: request.campaignId });
      return this.createFallbackMilestones(request, entityPool, themeAdaptation);
    }
  }

  /**
   * AIで生成されたマイルストーンを検証・フォーマット
   */
  private validateAndFormatMilestone(aiMilestone: any, request: MilestoneGenerationRequest): AIMilestone {
    const now = new Date().toISOString();
    
    return {
      id: aiMilestone.id || randomUUID(),
      campaignId: request.campaignId,
      sessionId: request.sessionId,
      title: aiMilestone.title || 'AI生成マイルストーン',
      description: aiMilestone.description || 'AIによって生成されたマイルストーン',
      type: aiMilestone.type || 'event_clear',
      targetId: aiMilestone.targetId || randomUUID(),
      targetDetails: aiMilestone.targetDetails || {
        entityType: 'event',
        entityId: aiMilestone.targetId || randomUUID(),
        specificConditions: {}
      },
      status: 'pending',
      progress: 0,
      requiredConditions: aiMilestone.requiredConditions || [],
      reward: aiMilestone.reward || {
        experiencePoints: 100,
        items: [],
        characterBenefits: {},
        storyProgression: `マイルストーン「${aiMilestone.title}」完了`
      },
      createdAt: now
    };
  }

  /**
   * フォールバックマイルストーン生成
   */
  private createFallbackMilestones(
    request: MilestoneGenerationRequest,
    entityPool: EntityPool,
    themeAdaptation: ThemeAdaptation
  ): AIMilestone[] {
    const milestones: AIMilestone[] = [];
    const now = new Date().toISOString();

    // 基本3個程度のマイルストーンを生成（フォールバック）
    const milestoneCount = Math.min(request.milestoneCount, 5); // 最大5個に制限

    for (let i = 0; i < milestoneCount; i++) {
      const milestoneType = this.selectMilestoneType(themeAdaptation);
      const targetEntity = this.selectTargetEntity(milestoneType, entityPool);
      
      if (!targetEntity) continue; // 対象エンティティがない場合はスキップ

      const milestone: AIMilestone = {
        id: randomUUID(),
        campaignId: request.campaignId,
        sessionId: request.sessionId,
        title: this.generateMilestoneTitle(milestoneType, targetEntity),
        description: this.generateMilestoneDescription(milestoneType, targetEntity),
        type: milestoneType,
        targetId: targetEntity.id,
        targetDetails: {
          entityType: this.getEntityTypeFromMilestoneType(milestoneType),
          entityId: targetEntity.id,
          specificConditions: this.generateSpecificConditions(milestoneType, targetEntity)
        },
        status: 'pending',
        progress: 0,
        requiredConditions: [],
        reward: {
          experiencePoints: this.calculateExperienceReward(milestoneType),
          items: [],
          characterBenefits: {},
          storyProgression: `マイルストーン「${this.generateMilestoneTitle(milestoneType, targetEntity)}」完了`
        },
        createdAt: now
      };

      // マイルストーンターゲットフラグを設定
      this.markEntityAsMilestoneTarget(targetEntity, entityPool);

      milestones.push(milestone);
    }

    return milestones;
  }

  /**
   * マイルストーンタイプの選択（テーマ適応）
   */
  private selectMilestoneType(themeAdaptation: ThemeAdaptation): MilestoneType {
    const availableTypes: MilestoneType[] = [];

    if (themeAdaptation.allowedEntityTypes.includes('enemy')) {
      availableTypes.push('enemy_defeat');
    }
    if (themeAdaptation.allowedEntityTypes.includes('event')) {
      availableTypes.push('event_clear');
    }
    if (themeAdaptation.allowedEntityTypes.includes('npc')) {
      availableTypes.push('npc_communication');
    }
    if (themeAdaptation.allowedEntityTypes.includes('item')) {
      availableTypes.push('item_acquisition');
    }
    if (themeAdaptation.allowedEntityTypes.includes('quest')) {
      availableTypes.push('quest_completion');
    }

    // ランダムに選択
    return availableTypes[Math.floor(Math.random() * availableTypes.length)];
  }

  /**
   * 対象エンティティの選択
   */
  private selectTargetEntity(milestoneType: MilestoneType, entityPool: EntityPool): any | null {
    const entities = entityPool.entities;

    switch (milestoneType) {
      case 'enemy_defeat':
        return entities.enemies.length > 0 ? entities.enemies[Math.floor(Math.random() * entities.enemies.length)] : null;
      case 'event_clear':
        return entities.events.length > 0 ? entities.events[Math.floor(Math.random() * entities.events.length)] : null;
      case 'npc_communication':
        return entities.npcs.length > 0 ? entities.npcs[Math.floor(Math.random() * entities.npcs.length)] : null;
      case 'item_acquisition':
        return entities.items.length > 0 ? entities.items[Math.floor(Math.random() * entities.items.length)] : null;
      case 'quest_completion':
        return entities.quests.length > 0 ? entities.quests[Math.floor(Math.random() * entities.quests.length)] : null;
      default:
        return null;
    }
  }

  /**
   * エネミー生成（仮実装）
   */
  private async generateEnemies(_request: MilestoneGenerationRequest, _themeAdaptation: ThemeAdaptation): Promise<PoolEnemy[]> {
    // TODO: AIを使って実際のエネミーを生成
    return [
      {
        id: randomUUID(),
        name: 'ゴブリン',
        description: '小柄で狡猾な緑色の怪物',
        level: 1,
        abilities: {
          hitPoints: 20,
          attackPower: 5,
          defense: 2,
          specialAbilities: ['素早い移動'],
          weaknesses: ['光魔法'],
          resistances: ['毒']
        },
        locationIds: [],
        isMilestoneTarget: false,
        rewards: [
          {
            type: 'experience',
            value: 50,
            description: 'ゴブリン討伐の経験値'
          }
        ],
        behavior: {
          aggression: 6,
          intelligence: 4,
          preferredTactics: ['群れでの攻撃', '罠の使用'],
          combatDialogue: ['グルルルル！', 'キィィィ！']
        }
      }
    ];
  }

  /**
   * イベント生成（仮実装）
   */
  private async generateEvents(_request: MilestoneGenerationRequest, _themeAdaptation: ThemeAdaptation): Promise<InteractiveEvent[]> {
    // TODO: AIを使って実際のイベントを生成
    return [
      {
        id: randomUUID(),
        name: '古い洞窟の探索',
        description: '村の外れにある古い洞窟から不思議な光が漏れている',
        locationIds: [],
        choices: [
          {
            id: randomUUID(),
            text: '洞窟に入る',
            description: '勇気を出して洞窟の中を調べる',
            requirements: [],
            consequences: []
          },
          {
            id: randomUUID(),
            text: '村人に相談する',
            description: '一旦村に戻って情報を集める',
            requirements: [],
            consequences: []
          }
        ],
        isMilestoneTarget: false,
        requiredConditions: [],
        outcomes: []
      }
    ];
  }

  /**
   * NPC生成（仮実装）
   */
  private async generateNPCs(_request: MilestoneGenerationRequest, _themeAdaptation: ThemeAdaptation): Promise<PoolNPC[]> {
    // TODO: AIを使って実際のNPCを生成
    return [
      {
        id: randomUUID(),
        name: '賢者エルウィン',
        description: '古い知識に詳しい村の長老',
        personality: {
          traits: ['知識豊富', '慎重', '親切'],
          goals: ['村の平和', '知識の継承'],
          fears: ['古代の封印が解かれること'],
          motivations: ['若い世代の成長']
        },
        locationIds: [],
        dialoguePatterns: [
          {
            trigger: 'greeting',
            responses: ['こんにちは、若者よ', 'お疲れのようじゃの'],
            mood: 'friendly'
          }
        ],
        communicationConditions: [
          {
            type: 'greeting',
            requiredRelationship: 0,
            availableResponses: ['古い伝説について教えて', '村の歴史を聞く']
          }
        ],
        isMilestoneTarget: false,
        relationshipLevel: 0
      }
    ];
  }

  /**
   * アイテム生成（仮実装）
   */
  private async generateItems(_request: MilestoneGenerationRequest, _themeAdaptation: ThemeAdaptation): Promise<PoolItem[]> {
    // TODO: AIを使って実際のアイテムを生成
    return [
      {
        id: randomUUID(),
        name: '古代の巻物',
        description: '古代文字で書かれた謎めいた巻物',
        type: 'key_item',
        rarity: 'rare',
        effects: [
          {
            type: 'special',
            magnitude: 0,
            description: '古代の知識を解読できる'
          }
        ],
        acquisitionMethods: [
          {
            type: 'exploration',
            sourceId: randomUUID(),
            probability: 0.3,
            conditions: ['洞窟の探索']
          }
        ],
        isMilestoneTarget: false,
        value: 1000
      }
    ];
  }

  /**
   * クエスト生成（仮実装）
   */
  private async generateQuests(_request: MilestoneGenerationRequest, _themeAdaptation: ThemeAdaptation): Promise<PoolQuest[]> {
    // TODO: AIを使って実際のクエストを生成
    return [
      {
        id: randomUUID(),
        title: '失われた村の秘宝',
        description: '村に代々伝わる秘宝が盗まれてしまった。犯人を見つけて秘宝を取り戻せ。',
        type: 'main',
        objectives: [
          {
            id: randomUUID(),
            description: '手がかりを探す',
            completed: false,
            optional: false,
            progress: 0,
            requirements: []
          }
        ],
        rewards: {
          experience: 200,
          currency: 500,
          items: [],
          storyProgression: ['村の信頼を得る'],
          relationshipChanges: {}
        },
        difficulty: 'medium',
        estimatedTime: 120,
        prerequisites: [],
        isMilestoneTarget: false
      }
    ];
  }

  /**
   * マイルストーンタイトル生成
   */
  private generateMilestoneTitle(type: MilestoneType, entity: any): string {
    switch (type) {
      case 'enemy_defeat':
        return `${entity.name}の討伐`;
      case 'event_clear':
        return `${entity.name}のクリア`;
      case 'npc_communication':
        return `${entity.name}との対話`;
      case 'item_acquisition':
        return `${entity.name}の取得`;
      case 'quest_completion':
        return `${entity.title}の完了`;
      default:
        return 'マイルストーン';
    }
  }

  /**
   * マイルストーン説明生成
   */
  private generateMilestoneDescription(type: MilestoneType, entity: any): string {
    switch (type) {
      case 'enemy_defeat':
        return `${entity.name}を倒してください。${entity.description}`;
      case 'event_clear':
        return `${entity.name}を完了してください。${entity.description}`;
      case 'npc_communication':
        return `${entity.name}と重要な会話を行ってください。${entity.description}`;
      case 'item_acquisition':
        return `${entity.name}を入手してください。${entity.description}`;
      case 'quest_completion':
        return `クエスト「${entity.title}」を完了してください。${entity.description}`;
      default:
        return 'マイルストーンを達成してください。';
    }
  }

  /**
   * エンティティタイプ取得
   */
  private getEntityTypeFromMilestoneType(type: MilestoneType): 'enemy' | 'event' | 'npc' | 'item' | 'quest' {
    switch (type) {
      case 'enemy_defeat': return 'enemy';
      case 'event_clear': return 'event';
      case 'npc_communication': return 'npc';
      case 'item_acquisition': return 'item';
      case 'quest_completion': return 'quest';
      default: return 'event'; // fallback
    }
  }

  /**
   * 特定条件生成
   */
  private generateSpecificConditions(type: MilestoneType, _entity: any): Record<string, any> {
    switch (type) {
      case 'npc_communication':
        return { requiredTopics: ['重要な情報', '村の歴史'] };
      case 'item_acquisition':
        return { requiredQuantity: 1 };
      default:
        return {};
    }
  }

  /**
   * 経験値報酬計算
   */
  private calculateExperienceReward(type: MilestoneType): number {
    const baseRewards: Record<MilestoneType, number> = {
      enemy_defeat: 100,
      event_clear: 75,
      npc_communication: 50,
      item_acquisition: 60,
      quest_completion: 150
    };
    
    return baseRewards[type] || 50;
  }

  /**
   * エンティティをマイルストーンターゲットとしてマーク
   */
  private markEntityAsMilestoneTarget(entity: any, _entityPool: EntityPool): void {
    if (entity && typeof entity === 'object' && 'isMilestoneTarget' in entity) {
      entity.isMilestoneTarget = true;
    }
  }

  /**
   * データベース保存
   */
  private async saveMilestonesAndPools(
    milestones: AIMilestone[], 
    entityPool: EntityPool, 
    themeAdaptation: ThemeAdaptation
  ): Promise<void> {
    logger.debug('💾 データベース保存開始', { 
      milestonesCount: milestones.length,
      entityPoolId: entityPool.id,
      themeId: themeAdaptation.themeId 
    });

    try {
      // マイルストーンを保存
      logger.debug('💾 マイルストーン保存開始');
      const milestoneStmt = this.db.prepare(`
        INSERT OR REPLACE INTO ai_milestones (
          id, campaign_id, session_id, title, description, type, target_id,
          target_details, status, progress, required_conditions, reward, created_at
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
      `);

      for (let i = 0; i < milestones.length; i++) {
        const milestone = milestones[i];
        
        // 各フィールドの詳細な値チェック
        const targetDetailsStr = JSON.stringify(milestone.targetDetails);
        const requiredConditionsStr = JSON.stringify(milestone.requiredConditions);
        const rewardStr = JSON.stringify(milestone.reward);
        
        logger.debug(`💾 マイルストーン ${i + 1} 保存詳細`, {
          id: milestone.id,
          title: milestone.title,
          allFieldValues: {
            id: milestone.id,
            campaignId: milestone.campaignId,
            sessionId: milestone.sessionId,
            title: milestone.title,
            description: milestone.description,
            type: milestone.type,
            targetId: milestone.targetId,
            targetDetailsStr: targetDetailsStr,
            status: milestone.status,
            progress: milestone.progress,
            requiredConditionsStr: requiredConditionsStr,
            rewardStr: rewardStr,
            createdAt: milestone.createdAt
          },
          hasNullValues: {
            id: milestone.id == null,
            campaignId: milestone.campaignId == null,
            sessionId: milestone.sessionId == null,
            title: milestone.title == null,
            description: milestone.description == null,
            type: milestone.type == null,
            targetId: milestone.targetId == null,
            targetDetailsStr: targetDetailsStr == null,
            status: milestone.status == null,
            progress: milestone.progress == null,
            requiredConditionsStr: requiredConditionsStr == null,
            rewardStr: rewardStr == null,
            createdAt: milestone.createdAt == null
          }
        });

        try {
          milestoneStmt.run([
            milestone.id,
            milestone.campaignId,
            milestone.sessionId,
            milestone.title,
            milestone.description,
            milestone.type,
            milestone.targetId,
            targetDetailsStr,
            milestone.status,
            milestone.progress,
            requiredConditionsStr,
            rewardStr,
            milestone.createdAt
          ]);
          logger.debug(`✅ マイルストーン ${i + 1} 保存成功`);
        } catch (error) {
          logger.error(`❌ マイルストーン ${i + 1} 保存エラー詳細`, { 
            error, 
            errorMessage: error instanceof Error ? error.message : 'Unknown error',
            milestone: {
              id: milestone.id,
              title: milestone.title,
              fields: [
                milestone.id,
                milestone.campaignId,
                milestone.sessionId,
                milestone.title,
                milestone.description,
                milestone.type,
                milestone.targetId,
                targetDetailsStr,
                milestone.status,
                milestone.progress,
                requiredConditionsStr,
                rewardStr,
                milestone.createdAt
              ]
            }
          });
          throw error;
        }
      }
      logger.debug('✅ マイルストーン保存完了');
    } catch (error) {
      logger.error('❌ マイルストーン保存エラー', { error });
      throw error;
    }

    try {
      // エンティティプールを保存
      logger.debug('💾 エンティティプール保存開始', {
        entityPoolData: {
          id: entityPool.id,
          campaignId: entityPool.campaignId,
          sessionId: entityPool.sessionId,
          themeId: entityPool.themeId,
          hasNullValues: {
            id: entityPool.id == null,
            campaignId: entityPool.campaignId == null,
            sessionId: entityPool.sessionId == null,
            themeId: entityPool.themeId == null,
            entities: entityPool.entities == null,
            generatedAt: entityPool.generatedAt == null,
            lastUpdated: entityPool.lastUpdated == null
          }
        }
      });

      const poolStmt = this.db.prepare(`
        INSERT OR REPLACE INTO entity_pools (
          id, campaign_id, session_id, theme_id, entities, generated_at, last_updated
        ) VALUES (?, ?, ?, ?, ?, ?, ?)
      `);

      poolStmt.run([
        entityPool.id,
        entityPool.campaignId,
        entityPool.sessionId,
        entityPool.themeId,
        JSON.stringify(entityPool.entities),
        entityPool.generatedAt,
        entityPool.lastUpdated
      ]);
      logger.debug('✅ エンティティプール保存完了');
    } catch (error) {
      logger.error('❌ エンティティプール保存エラー', { error, entityPool });
      throw error;
    }

    try {
      // テーマ適応を保存
      logger.debug('💾 テーマ適応保存開始', {
        themeAdaptationData: {
          themeId: themeAdaptation.themeId,
          hasNullValues: {
            themeId: themeAdaptation.themeId == null,
            allowedEntityTypes: themeAdaptation.allowedEntityTypes == null,
            restrictedEntityTypes: themeAdaptation.restrictedEntityTypes == null,
            specializations: themeAdaptation.specializations == null,
            contentModifiers: themeAdaptation.contentModifiers == null
          }
        }
      });

      const themeStmt = this.db.prepare(`
        INSERT OR REPLACE INTO theme_adaptations (
          id, theme_id, allowed_entity_types, restricted_entity_types,
          specializations, content_modifiers, created_at
        ) VALUES (?, ?, ?, ?, ?, ?, ?)
      `);

      themeStmt.run([
        randomUUID(),
        themeAdaptation.themeId,
        JSON.stringify(themeAdaptation.allowedEntityTypes),
        JSON.stringify(themeAdaptation.restrictedEntityTypes),
        JSON.stringify(themeAdaptation.specializations),
        JSON.stringify(themeAdaptation.contentModifiers),
        new Date().toISOString()
      ]);
      logger.debug('✅ テーマ適応保存完了');
    } catch (error) {
      logger.error('❌ テーマ適応保存エラー', { error, themeAdaptation });
      throw error;
    }

    logger.debug('✅ データベース保存完了');
  }

  /**
   * 生成履歴の保存
   */
  private async saveGenerationHistory(
    request: MilestoneGenerationRequest,
    response: MilestoneGenerationResponse
  ): Promise<void> {
    const stmt = this.db.prepare(`
      INSERT INTO milestone_generation_history (
        id, campaign_id, session_id, generation_metadata, generated_at
      ) VALUES (?, ?, ?, ?, ?)
    `);

    stmt.run([
      randomUUID(),
      request.campaignId,
      request.sessionId,
      JSON.stringify(response.generationMetadata),
      response.generationMetadata.generatedAt
    ]);
  }

  /**
   * キャンペーンのマイルストーン取得
   */
  async getAIMilestonesByCampaign(campaignId: ID): Promise<AIMilestone[]> {
    const stmt = this.db.prepare(`
      SELECT * FROM ai_milestones 
      WHERE campaign_id = ? 
      ORDER BY created_at ASC
    `);
    
    const rows = stmt.all(campaignId) as any[];
    
    return rows.map((row): AIMilestone => ({
      id: row.id,
      campaignId: row.campaign_id,
      sessionId: row.session_id,
      title: row.title,
      description: row.description,
      type: row.type,
      targetId: row.target_id,
      targetDetails: JSON.parse(row.target_details),
      status: row.status,
      progress: row.progress,
      requiredConditions: JSON.parse(row.required_conditions),
      reward: JSON.parse(row.reward),
      createdAt: row.created_at,
      completedAt: row.completed_at
    }));
  }

  /**
   * セッションのエンティティプール取得
   */
  async getEntityPoolBySession(sessionId: ID): Promise<EntityPool | null> {
    const stmt = this.db.prepare('SELECT * FROM entity_pools WHERE session_id = ?');
    const row = stmt.get(sessionId) as any;
    
    if (!row) return null;

    return {
      id: row.id,
      campaignId: row.campaign_id,
      sessionId: row.session_id,
      themeId: row.theme_id,
      entities: JSON.parse(row.entities),
      generatedAt: row.generated_at,
      lastUpdated: row.last_updated
    };
  }

  /**
   * マイルストーン進捗更新
   */
  async updateMilestoneProgress(milestoneId: ID, progress: number, status?: 'pending' | 'in_progress' | 'completed'): Promise<void> {
    const updates: string[] = ['progress = ?'];
    const values: any[] = [progress];

    if (status) {
      updates.push('status = ?');
      values.push(status);
      
      if (status === 'completed') {
        updates.push('completed_at = ?');
        values.push(new Date().toISOString());
      }
    }

    values.push(milestoneId);

    const stmt = this.db.prepare(`
      UPDATE ai_milestones SET ${updates.join(', ')} WHERE id = ?
    `);

    stmt.run(values);
  }

  /**
   * マイルストーン削除
   */
  async deleteAIMilestone(milestoneId: ID): Promise<void> {
    const stmt = this.db.prepare(`
      DELETE FROM ai_milestones WHERE id = ?
    `);

    const result = stmt.run(milestoneId);
    
    if (result.changes === 0) {
      throw new Error(`Milestone with ID ${milestoneId} not found`);
    }

    logger.info('✅ マイルストーン削除成功', { 
      milestoneId,
      deletedRows: result.changes 
    });
  }

  // =============================================================================
  // トップダウンアプローチ実装メソッド群
  // =============================================================================

  /**
   * Phase 1: マイルストーン概要生成
   * テーマとセッション設定に基づいて基本的なマイルストーン構造を生成
   */
  private async generateMilestoneOutlines(
    request: MilestoneGenerationRequest,
    themeAdaptation: ThemeAdaptation
  ): Promise<any[]> {
    logger.info('📋 マイルストーン概要生成開始', { milestoneCount: request.milestoneCount });

    const aiService = getAIService();
    
    // テーマに応じたマイルストーンタイプの制限
    const allowedTypes = ['特定エネミー討伐', '特定イベントクリア', '特定NPCとの特定コミュニケーション', 'キーアイテム取得', 'クエストクリア'];
    const restrictedTypes = themeAdaptation.restrictedEntityTypes || [];
    const availableTypes = allowedTypes.filter(type => !restrictedTypes.includes(type));

    const prompt = `
以下の条件でTRPGマイルストーンの概要を生成してください：

**基本設定:**
- セッション時間: ${request.sessionDuration?.estimatedPlayTime || 60}分
- マイルストーン数: ${request.milestoneCount || 3}個
- テーマ: ${request.themeId}
- 利用可能なマイルストーンタイプ: ${availableTypes.join(', ')}

**マイルストーン概要要件:**
1. 各マイルストーンは3つのエンティティで構成される
2. プレイヤーには進捗を直接表示しない（手探り感重視）
3. 物語的な一貫性を保つ
4. 難易度は段階的に上昇

**出力形式:**
[
  {
    "id": "milestone-1",
    "title": "謎の事件の発端",
    "description": "村で起こった不可解な事件の真相に迫る最初の手がかりを見つける",
    "type": "特定イベントクリア",
    "estimatedDuration": 20,
    "storyPosition": "beginning",
    "requiredEntityCount": 3
  }
]
`;

    try {
      const response = await aiService.chat({
        provider: 'google',
        apiKey: process.env.GOOGLE_API_KEY || '',
        message: prompt,
        persona: 'trpg_scenario_expert'
      });
      const milestoneOutlines = JSON.parse(response.message);
      
      logger.info('✅ マイルストーン概要生成完了', { 
        count: milestoneOutlines.length,
        types: milestoneOutlines.map((m: any) => m.type)
      });
      
      return milestoneOutlines;
    } catch (error) {
      logger.error('❌ マイルストーン概要生成失敗', { error });
      throw new AIServiceError('マイルストーン概要生成に失敗しました', 'MILESTONE_OUTLINE_GENERATION_FAILED');
    }
  }

  /**
   * Phase 1: マイルストーン関係性設定
   * マイルストーン間の依存関係と進行順序を定義
   */
  private async defineMilestoneRelations(
    milestoneOutlines: any[]
  ): Promise<any[]> {
    logger.info('🔗 マイルストーン関係性設定開始');

    const aiService = getAIService();
    
    const prompt = `
以下のマイルストーン概要に対して、関係性と依存関係を設定してください：

**マイルストーン概要:**
${JSON.stringify(milestoneOutlines, null, 2)}

**関係性設定要件:**
1. 物語の流れに沿った順序設定
2. 前提条件の明確化
3. 並行実行可能なマイルストーンの特定
4. プレイヤーの自由度を保つバランス

**出力形式:**
[
  {
    "milestoneId": "milestone-1",
    "prerequisites": [],
    "unlocks": ["milestone-2"],
    "canParallelWith": [],
    "storyWeight": 1.0,
    "progressContribution": 33.33
  }
]
`;

    try {
      const response = await aiService.chat({
        provider: 'google',
        apiKey: process.env.GOOGLE_API_KEY || '',
        message: prompt,
        persona: 'trpg_scenario_expert'
      });
      const milestoneRelations = JSON.parse(response.message);
      
      logger.info('✅ マイルストーン関係性設定完了', { 
        relationCount: milestoneRelations.length
      });
      
      return milestoneRelations;
    } catch (error) {
      logger.error('❌ マイルストーン関係性設定失敗', { error });
      throw new AIServiceError('マイルストーン関係性設定に失敗しました', 'MILESTONE_RELATIONS_FAILED');
    }
  }

  /**
   * Phase 2: コアエンティティ要件決定
   * 各マイルストーンに必要なエンティティの要件を定義
   */
  private async defineCoreEntityRequirements(
    milestoneRelations: any[],
    themeAdaptation: ThemeAdaptation
  ): Promise<any> {
    logger.info('🎯 コアエンティティ要件決定開始');

    const aiService = getAIService();
    
    const prompt = `
以下のマイルストーン関係性に基づいて、必要なコアエンティティの要件を決定してください：

**マイルストーン関係性:**
${JSON.stringify(milestoneRelations, null, 2)}

**テーマ制約:**
- 許可エンティティタイプ: ${themeAdaptation.allowedEntityTypes.join(', ')}
- 制限エンティティタイプ: ${themeAdaptation.restrictedEntityTypes.join(', ')}
- 特殊化要素: ${themeAdaptation.specializations.join(', ')}

**要件決定条件:**
1. 各マイルストーンに3つのエンティティを配置
2. エンティティタイプのバランス（enemies, events, npcs, items, quests）
3. 進捗貢献度の設定（通常は33%ずつ）
4. 物語的整合性の保持

**出力形式:**
{
  "milestone-1": {
    "entities": [
      {
        "type": "event",
        "role": "investigation_start",
        "progressContribution": 33,
        "requirements": "村の中央で調査イベント"
      },
      {
        "type": "npc", 
        "role": "witness",
        "progressContribution": 33,
        "requirements": "目撃者NPCとの対話"
      },
      {
        "type": "item",
        "role": "evidence",
        "progressContribution": 34,
        "requirements": "決定的証拠アイテムの発見"
      }
    ]
  }
}
`;

    try {
      const response = await aiService.chat({
        provider: 'google',
        apiKey: process.env.GOOGLE_API_KEY || '',
        message: prompt,
        persona: 'trpg_entity_designer'
      });
      const entityRequirements = JSON.parse(response.message);
      
      logger.info('✅ コアエンティティ要件決定完了', { 
        milestoneCount: Object.keys(entityRequirements).length
      });
      
      return entityRequirements;
    } catch (error) {
      logger.error('❌ コアエンティティ要件決定失敗', { error });
      throw new AIServiceError('コアエンティティ要件決定に失敗しました', 'CORE_ENTITY_REQUIREMENTS_FAILED');
    }
  }

  /**
   * Phase 2: コアエンティティ生成
   * マイルストーン達成に必須のエンティティを生成
   */
  private async generateCoreEntities(
    entityRequirements: any,
    request: MilestoneGenerationRequest,
    themeAdaptation: ThemeAdaptation
  ): Promise<any> {
    logger.info('🎲 コアエンティティ生成開始');

    const aiService = getAIService();
    
    const prompt = `
以下の要件に基づいて、コアエンティティを生成してください：

**エンティティ要件:**
${JSON.stringify(entityRequirements, null, 2)}

**テーマ情報:**
- テーマID: ${request.themeId}
- コンテンツ修正要素: ${themeAdaptation.contentModifiers.join(', ')}

**生成条件:**
1. 各エンティティは明確な目的を持つ
2. 適切な難易度設定
3. 報酬設定（経験値、アイテム、情報）
4. 日本語での自然な表現

**出力形式:**
{
  "enemies": [
    {
      "id": "enemy-001",
      "name": "村の真犯人",
      "description": "事件の真相を隠そうとする謎の人物",
      "level": 3,
      "milestoneId": "milestone-1",
      "progressContribution": 34,
      "rewards": {
        "experience": 80,
        "items": ["決定的証拠"],
        "information": ["事件の真相"]
      }
    }
  ],
  "events": [
    {
      "id": "event-001", 
      "name": "血痕の調査",
      "description": "現場に残された血痕を詳しく調べる",
      "milestoneId": "milestone-1",
      "progressContribution": 33,
      "rewards": {
        "experience": 50,
        "information": ["犯人は左利きの可能性"],
        "items": []
      }
    }
  ],
  "npcs": [
    {
      "id": "npc-001",
      "name": "目撃者の村人",
      "description": "事件当夜に怪しい人影を見た村人",
      "milestoneId": "milestone-1", 
      "progressContribution": 33,
      "rewards": {
        "experience": 40,
        "information": ["事件当夜の怪しい人影"],
        "relationships": [{"npcId": "witness-001", "change": 20}]
      }
    }
  ],
  "items": [],
  "quests": []
}
`;

    try {
      const response = await aiService.chat({
        provider: 'google',
        apiKey: process.env.GOOGLE_API_KEY || '',
        message: prompt,
        persona: 'trpg_entity_generator'
      });
      const coreEntities = JSON.parse(response.message);
      
      logger.info('✅ コアエンティティ生成完了', { 
        enemies: coreEntities.enemies?.length || 0,
        events: coreEntities.events?.length || 0,
        npcs: coreEntities.npcs?.length || 0,
        items: coreEntities.items?.length || 0,
        quests: coreEntities.quests?.length || 0
      });
      
      return coreEntities;
    } catch (error) {
      logger.error('❌ コアエンティティ生成失敗', { error });
      throw new AIServiceError('コアエンティティ生成に失敗しました', 'CORE_ENTITY_GENERATION_FAILED');
    }
  }

  /**
   * Phase 2: 追加エンティティ生成
   * 報酬・体験向上系のボーナスエンティティを生成
   */
  private async generateBonusEntities(
    request: MilestoneGenerationRequest,
    coreEntities: any
  ): Promise<any> {
    logger.info('🎁 追加エンティティ生成開始');

    const aiService = getAIService();
    
    const prompt = `
以下の条件で追加エンティティ（ボーナス系）を生成してください：

**コアエンティティ情報:**
${JSON.stringify(coreEntities, null, 2)}

**生成要件:**
1. **実用的報酬エンティティ**: 2個程度（装備、回復アイテム、スキル強化）
2. **トロフィー・収集系エンティティ**: 2個程度（コレクション要素、ストーリー深化）
3. **ミステリー系エンティティ**: 2個程度（謎要素、隠し要素）

**制約:**
- マイルストーン進捗には寄与しない
- プレイヤーの探索意欲を高める
- テーマ: ${request.themeId}

**出力形式:**
{
  "practicalRewards": [
    {
      "id": "practical-001",
      "name": "古い武器庫の発見",
      "type": "equipment",
      "description": "村の古い倉庫で武器庫を発見",
      "rewards": {
        "items": [
          {"name": "魔法強化の剣", "effect": "攻撃力+15", "rarity": "rare"},
          {"name": "守護の盾", "effect": "防御力+12", "rarity": "uncommon"}
        ],
        "experience": 30
      }
    }
  ],
  "trophyItems": [
    {
      "id": "trophy-001", 
      "name": "古い人形の発見",
      "description": "昔の職人が作った精巧な人形",
      "rewards": {
        "items": [
          {
            "name": "村娘の人形",
            "effect": "なし",
            "description": "特に効果はないが、村の歴史を感じさせる",
            "category": "trophy",
            "rarity": "unique"
          }
        ],
        "information": ["村の古い伝統について"],
        "experience": 10
      }
    }
  ],
  "mysteryItems": [
    {
      "id": "mystery-001",
      "name": "謎めいた老人との遭遇",
      "description": "意味深な言葉を残す謎の老人",
      "rewards": {
        "items": [
          {
            "name": "謎の石ころ",
            "effect": "なし",
            "description": "いつか役に立つかもしれない普通の石",
            "category": "mystery_item"
          }
        ],
        "information": ["意味深な言葉", "世界の不思議について"],
        "experience": 5
      }
    }
  ]
}
`;

    try {
      const response = await aiService.chat({
        provider: 'google',
        apiKey: process.env.GOOGLE_API_KEY || '',
        message: prompt,
        persona: 'trpg_bonus_designer'
      });
      const bonusEntities = JSON.parse(response.message);
      
      logger.info('✅ 追加エンティティ生成完了', { 
        practical: bonusEntities.practicalRewards?.length || 0,
        trophy: bonusEntities.trophyItems?.length || 0,
        mystery: bonusEntities.mysteryItems?.length || 0
      });
      
      return bonusEntities;
    } catch (error) {
      logger.error('❌ 追加エンティティ生成失敗', { error });
      throw new AIServiceError('追加エンティティ生成に失敗しました', 'BONUS_ENTITY_GENERATION_FAILED');
    }
  }

  /**
   * Phase 2: 場所配置最適化
   * エンティティを適切な場所に配置し、時間条件・前提条件を設定
   */
  private async generateLocationMappings(
    coreEntities: any,
    bonusEntities: any
  ): Promise<any[]> {
    logger.info('📍 場所配置最適化開始');

    const aiService = getAIService();
    
    const prompt = `
以下のエンティティを適切な場所に配置してください：

**コアエンティティ:**
${JSON.stringify(coreEntities, null, 2)}

**ボーナスエンティティ:**
${JSON.stringify(bonusEntities, null, 2)}

**配置要件:**
1. 各場所に適切なエンティティを配置
2. 時間条件の設定（day_time, night_only, any）
3. 前提条件の設定（他エンティティの達成が必要）
4. プレイヤーの自然な探索流れを考慮

**出力形式:**
[
  {
    "id": "mapping-001",
    "locationId": "village-center",
    "locationName": "村の中央広場",
    "entityId": "npc-001",
    "entityType": "core",
    "entityCategory": "npc",
    "timeConditions": ["day_time"],
    "prerequisiteEntities": [],
    "isAvailable": true
  },
  {
    "id": "mapping-002",
    "locationId": "crime-scene", 
    "locationName": "事件現場",
    "entityId": "event-001",
    "entityType": "core",
    "entityCategory": "event",
    "timeConditions": ["any"],
    "prerequisiteEntities": []
  }
]
`;

    try {
      const response = await aiService.chat({
        provider: 'google',
        apiKey: process.env.GOOGLE_API_KEY || '',
        message: prompt,
        persona: 'trpg_location_mapper'
      });
      const locationMappings = JSON.parse(response.message);
      
      logger.info('✅ 場所配置最適化完了', { 
        mappingCount: locationMappings.length
      });
      
      return locationMappings;
    } catch (error) {
      logger.error('❌ 場所配置最適化失敗', { error });
      throw new AIServiceError('場所配置最適化に失敗しました', 'LOCATION_MAPPING_FAILED');
    }
  }

  /**
   * Phase 3: マイルストーン詳細化
   * コアエンティティの情報を基にマイルストーンの詳細を設定
   */
  private async detailizeMilestones(
    milestoneOutlines: any[],
    coreEntities: any
  ): Promise<AIMilestone[]> {
    logger.info('📝 マイルストーン詳細化開始');

    const detailedMilestones: AIMilestone[] = [];

    for (const outline of milestoneOutlines) {
      // 該当するコアエンティティを取得
      const relatedEntities = this.getEntitiesForMilestone(outline.id, coreEntities);
      
      const milestone: AIMilestone = {
        id: randomUUID(),
        campaignId: '', // 後でcommitToDatabase時に設定
        sessionId: '', // 後でcommitToDatabase時に設定
        title: outline.title,
        description: outline.description,
        type: outline.type as MilestoneType,
        targetEntityIds: relatedEntities.map((e: any) => e.id),
        targetDetails: relatedEntities.map((e: any) => ({
          entityId: e.id,
          entityType: this.getEntityTypeFromEntity(e),
          specificConditions: {
            name: e.name,
            description: e.description,
            progressContribution: e.progressContribution || 33
          }
        })),
        progressContributions: relatedEntities.map((e: any) => e.progressContribution || 33),
        status: 'pending',
        progress: 0,
        hiddenFromPlayer: true, // 手探り感のためプレイヤーには非表示
        requiredConditions: [],
        reward: {
          experiencePoints: relatedEntities.reduce((sum: number, e: any) => 
            sum + (e.rewards?.experience || 0), 0),
          items: relatedEntities.flatMap((e: any) => e.rewards?.items || []).map((item: any) => item.id || item),
          characterBenefits: {
            information: relatedEntities.flatMap((e: any) => e.rewards?.information || [])
          },
          storyProgression: "マイルストーン達成による物語進行"
        },
        createdAt: new Date().toISOString(),
        completedAt: undefined
      };

      detailedMilestones.push(milestone);
    }

    logger.info('✅ マイルストーン詳細化完了', { 
      milestoneCount: detailedMilestones.length
    });

    return detailedMilestones;
  }

  /**
   * Phase 3: システムバランス調整
   * 難易度、報酬、進捗のバランスを調整
   */
  private async balanceSystem(
    milestones: AIMilestone[],
    coreEntities: any,
    bonusEntities: any
  ): Promise<any> {
    logger.info('⚖️ システムバランス調整開始');

    // 経験値バランス調整
    const totalCoreExperience = this.calculateTotalExperience(coreEntities);
    
    const balanceRatio = 0.7; // コア70%, ボーナス30%の比率
    const adjustedBonusEntities = this.adjustBonusRewards(bonusEntities, totalCoreExperience, balanceRatio);

    // 進捗貢献度の正規化
    const normalizedMilestones = milestones.map(milestone => {
      const totalContribution = milestone.progressContributions.reduce((sum, val) => sum + val, 0);
      if (Math.abs(totalContribution - 100) > 1) {
        // 100%に正規化
        const factor = 100 / totalContribution;
        milestone.progressContributions = milestone.progressContributions.map(val => 
          Math.round(val * factor)
        );
      }
      return milestone;
    });

    const balancedSystem = {
      milestones: normalizedMilestones,
      coreEntities,
      bonusEntities: adjustedBonusEntities,
      balanceMetrics: {
        totalCoreExperience,
        totalBonusExperience: this.calculateTotalExperience(adjustedBonusEntities),
        coreEntityCount: this.countAllEntities(coreEntities),
        bonusEntityCount: this.countAllEntities(adjustedBonusEntities)
      }
    };

    logger.info('✅ システムバランス調整完了', balancedSystem.balanceMetrics);

    return balancedSystem;
  }

  /**
   * Phase 3: データベース一括コミット
   * 生成されたすべてのデータをデータベースに保存
   */
  private async commitToDatabase(balancedSystem: any): Promise<MilestoneGenerationResponse> {
    logger.info('💾 データベース一括コミット開始');

    try {
      // トランザクション開始
      const insertMilestone = this.db.prepare(`
        INSERT INTO ai_milestones (
          id, campaign_id, session_id, title, description, type,
          target_entity_ids, progress_contributions, target_details,
          status, progress, hidden_from_player, required_conditions, reward, created_at
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
      `);

      const insertEntityPool = this.db.prepare(`
        INSERT INTO entity_pools (
          id, campaign_id, session_id, theme_id, 
          core_entities, bonus_entities, entities, generated_at, last_updated
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
      `);

      // マイルストーン保存
      const savedMilestones: AIMilestone[] = [];
      for (const milestone of balancedSystem.milestones) {
        const milestoneWithIds = {
          ...milestone,
          campaignId: balancedSystem.campaignId || '',
          sessionId: balancedSystem.sessionId || ''
        };

        insertMilestone.run(
          milestoneWithIds.id,
          milestoneWithIds.campaignId,
          milestoneWithIds.sessionId,
          milestoneWithIds.title,
          milestoneWithIds.description,
          milestoneWithIds.type,
          JSON.stringify(milestoneWithIds.targetEntityIds),
          JSON.stringify(milestoneWithIds.progressContributions),
          JSON.stringify(milestoneWithIds.targetDetails),
          milestoneWithIds.status,
          milestoneWithIds.progress,
          milestoneWithIds.hiddenFromPlayer,
          JSON.stringify(milestoneWithIds.requiredConditions),
          JSON.stringify(milestoneWithIds.reward),
          milestoneWithIds.createdAt
        );

        savedMilestones.push(milestoneWithIds);
      }

      // エンティティプール保存
      const entityPoolId = randomUUID();
      const entityPoolData: EntityPoolCollection = {
        // 従来の構造（後方互換性）
        enemies: balancedSystem.coreEntities.enemies || [],
        events: balancedSystem.coreEntities.events || [],
        npcs: balancedSystem.coreEntities.npcs || [],
        items: balancedSystem.coreEntities.items || [],
        quests: balancedSystem.coreEntities.quests || [],
        
        // 新しい二層構造
        coreEntities: balancedSystem.coreEntities,
        bonusEntities: balancedSystem.bonusEntities
      };

      insertEntityPool.run(
        entityPoolId,
        balancedSystem.campaignId || '',
        balancedSystem.sessionId || '',
        balancedSystem.themeId || 'default',
        JSON.stringify(balancedSystem.coreEntities),
        JSON.stringify(balancedSystem.bonusEntities),
        JSON.stringify(entityPoolData), // 後方互換性のため
        new Date().toISOString(),
        new Date().toISOString()
      );

      const response: MilestoneGenerationResponse = {
        milestones: savedMilestones,
        entityPool: {
        id: entityPoolId,
        campaignId: balancedSystem.campaignId || '',
        sessionId: balancedSystem.sessionId || '',
        themeId: balancedSystem.themeId || 'default',
        entities: entityPoolData,
        generatedAt: new Date().toISOString(),
        lastUpdated: new Date().toISOString()
      },
        themeAdaptation: balancedSystem.themeAdaptation || {
          allowedEntityTypes: [],
          restrictedEntityTypes: [],
          specializations: [],
          contentModifiers: []
        },
        generationMetadata: balancedSystem.generationMetadata || {
          model: 'gemini-2.0-flash-lite',
          prompt: 'Top-down scenario generation',
          tokensUsed: 0,
          processingTime: 0,
          generatedAt: new Date().toISOString()
        }
      };

      logger.info('✅ データベース一括コミット完了', { 
        milestonesCount: savedMilestones.length,
        entityPoolId
      });

      return response;

    } catch (error) {
      logger.error('❌ データベース一括コミット失敗', { error });
      throw new AIServiceError('データベース保存に失敗しました', 'DATABASE_COMMIT_FAILED');
    }
  }

  // =============================================================================
  // ヘルパーメソッド群
  // =============================================================================

  private getEntitiesForMilestone(milestoneId: string, coreEntities: any): any[] {
    const allEntities = [
      ...(coreEntities.enemies || []),
      ...(coreEntities.events || []),
      ...(coreEntities.npcs || []),
      ...(coreEntities.items || []),
      ...(coreEntities.quests || [])
    ];
    
    return allEntities.filter((entity: any) => entity.milestoneId === milestoneId);
  }

  private getEntityTypeFromEntity(entity: any): 'enemy' | 'event' | 'npc' | 'item' | 'quest' {
    // エンティティの構造から型を推定
    if (entity.level !== undefined) return 'enemy';
    if (entity.rewards && entity.description) return 'event';
    if (entity.relationships) return 'npc';
    if (entity.effect) return 'item';
    return 'quest';
  }

  private calculateTotalExperience(entities: any): number {
    if (!entities) return 0;
    
    let total = 0;
    Object.values(entities).forEach((entityList: any) => {
      if (Array.isArray(entityList)) {
        total += entityList.reduce((sum: number, entity: any) => 
          sum + (entity.rewards?.experience || 0), 0);
      }
    });
    
    return total;
  }

  private countAllEntities(entities: any): number {
    if (!entities) return 0;
    
    let count = 0;
    Object.values(entities).forEach((entityList: any) => {
      if (Array.isArray(entityList)) {
        count += entityList.length;
      }
    });
    
    return count;
  }

  private adjustBonusRewards(bonusEntities: any, coreExperience: number, ratio: number): any {
    // ボーナス報酬を適切な比率に調整
    const targetBonusExperience = coreExperience * ratio / (1 - ratio);
    const currentBonusExperience = this.calculateTotalExperience(bonusEntities);
    
    if (currentBonusExperience === 0) return bonusEntities;
    
    const adjustmentFactor = targetBonusExperience / currentBonusExperience;
    
    // 各ボーナスエンティティの経験値を調整
    const adjusted = { ...bonusEntities };
    Object.keys(adjusted).forEach(key => {
      if (Array.isArray(adjusted[key])) {
        adjusted[key] = adjusted[key].map((entity: any) => ({
          ...entity,
          rewards: {
            ...entity.rewards,
            experience: Math.round((entity.rewards?.experience || 0) * adjustmentFactor)
          }
        }));
      }
    });
    
    return adjusted;
  }
}

// Lazy initialization
let _aiMilestoneGenerationService: AIMilestoneGenerationService | null = null;
export function getAIMilestoneGenerationService(): AIMilestoneGenerationService {
  if (!_aiMilestoneGenerationService) {
    _aiMilestoneGenerationService = new AIMilestoneGenerationService();
  }
  return _aiMilestoneGenerationService;
}