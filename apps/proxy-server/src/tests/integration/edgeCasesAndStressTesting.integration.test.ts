/**
 * Edge Cases and Stress Testing Integration Tests
 * Testing boundary conditions, extreme scenarios, and system limits
 * Using t-WADA naming conventions and production types
 */

import { describe, it, expect, beforeAll, afterAll, beforeEach } from '@jest/globals';
import request from 'supertest';
import express, { Express } from 'express';
import { Server } from 'http';
import { Database as DatabaseType } from 'better-sqlite3';
import { Worker, isMainThread, parentPort, workerData } from 'worker_threads';
import { performance } from 'perf_hooks';
import { 
  TRPGCampaign, 
  TRPGSession, 
  TRPGCharacter,
  Location,
  Quest,
  APIResponse 
} from '@ai-agent-trpg/types';
import { campaignsRouter } from '../../routes/campaigns';
import { sessionsRouter } from '../../routes/sessions';
import { charactersRouter } from '../../routes/characters';
import { locationsRouter } from '../../routes/locations';
import { aiAgentRouter } from '../../routes/aiAgent';
import { errorHandler } from '../../middleware/errorHandler';
import { fullIntegrationMockSetup, MockServerServices } from '../mocks';
import { testDatabase, TestDataFactory } from '../setup/testDatabase';

describe('Edge Cases and Stress Testing Integration Tests', () => {
  let app: Express;
  let server: Server;
  let db: DatabaseType;
  let mockServices: MockServerServices;

  beforeAll(async () => {
    // Set up test database with higher limits for stress testing
    db = testDatabase.createTestDatabase();
    
    // Set up express app with all routes
    app = express();
    app.use(express.json({ limit: '100mb' }));
    app.use('/api/campaigns', campaignsRouter);
    app.use('/api/sessions', sessionsRouter);
    app.use('/api/characters', charactersRouter);
    app.use('/api/locations', locationsRouter);
    app.use('/api/ai-agent', aiAgentRouter);
    app.use(errorHandler);

    // Initialize mock services with stress testing capabilities
    mockServices = await fullIntegrationMockSetup({
      stressTestMode: true,
      maxConcurrentRequests: 1000
    });
    
    // Start server
    server = app.listen(0);

    // Increase Jest timeout for stress tests
    jest.setTimeout(300000); // 5 minutes
  });

  afterAll(async () => {
    await mockServices.cleanup();
    testDatabase.closeAllDatabases();
    server.close();
  });

  beforeEach(async () => {
    testDatabase.resetDatabase(db);
    await mockServices.reset();
  });

  describe('境界条件とエッジケース', () => {
    it('Should handle extremely large campaign data without performance degradation', async () => {
      // Create campaign with maximum allowed size
      const maxCampaign = TestDataFactory.createTestCampaign({\n        name: 'X'.repeat(500), // Max name length\n        description: 'D'.repeat(50000), // 50KB description\n        settings: {\n          maxPlayers: 100,\n          systemType: 'Custom System with Very Long Name That Tests Length Limits',\n          worldType: 'multi-dimensional-ultra-complex-fantasy-sci-fi-hybrid-universe',\n          customRules: Array.from({ length: 1000 }, (_, i) => ({\n            id: `rule-${i}`,\n            name: `Custom Rule ${i}`,\n            description: `This is a very detailed custom rule description that goes on for quite a while to test the system's ability to handle large amounts of text data without any performance issues or corruption. Rule number ${i} of 1000.`\n          }))\n        }\n      });\n\n      const startTime = performance.now();\n      const response = await request(app)\n        .post('/api/campaigns')\n        .send(maxCampaign)\n        .expect(201);\n      const creationTime = performance.now() - startTime;\n\n      expect(creationTime).toBeLessThan(5000); // Should complete within 5 seconds\n      expect(response.body.success).toBe(true);\n      expect(response.body.data.name).toBe(maxCampaign.name);\n\n      const campaignId = response.body.data.id;\n\n      // Create maximum number of characters\n      const maxCharacters = 1000;\n      const batchSize = 50;\n      const batches = Math.ceil(maxCharacters / batchSize);\n\n      for (let batch = 0; batch < batches; batch++) {\n        const batchCharacters = [];\n        for (let i = 0; i < batchSize && (batch * batchSize + i) < maxCharacters; i++) {\n          const index = batch * batchSize + i;\n          batchCharacters.push(TestDataFactory.createTestCharacter(campaignId, {\n            name: `Character ${index}`,\n            description: `Character description ${index} `.repeat(100), // 2KB description\n            stats: {\n              attributes: Array.from({ length: 50 }, (_, j) => ({\n                name: `Attribute${j}`,\n                value: Math.floor(Math.random() * 100)\n              })),\n              skills: Array.from({ length: 100 }, (_, j) => ({\n                name: `Skill${j}`,\n                level: Math.floor(Math.random() * 20)\n              }))\n            }\n          }));\n        }\n\n        const batchStartTime = performance.now();\n        const batchResponse = await request(app)\n          .post('/api/characters/batch')\n          .send({ characters: batchCharacters })\n          .expect(201);\n        const batchTime = performance.now() - batchStartTime;\n\n        expect(batchTime).toBeLessThan(10000); // Each batch should complete within 10 seconds\n        expect(batchResponse.body.data.created).toHaveLength(batchCharacters.length);\n      }\n\n      // Test querying large dataset\n      const queryStartTime = performance.now();\n      const queryResponse = await request(app)\n        .get(`/api/characters?campaignId=${campaignId}&limit=100`)\n        .expect(200);\n      const queryTime = performance.now() - queryStartTime;\n\n      expect(queryTime).toBeLessThan(2000); // Query should be fast even with large dataset\n      expect(queryResponse.body.data).toHaveLength(100);\n      expect(queryResponse.body.pagination.total).toBe(maxCharacters);\n\n      // Test search performance on large dataset\n      const searchStartTime = performance.now();\n      const searchResponse = await request(app)\n        .get(`/api/characters/search?q=Character%20500&campaignId=${campaignId}`)\n        .expect(200);\n      const searchTime = performance.now() - searchStartTime;\n\n      expect(searchTime).toBeLessThan(3000); // Search should be reasonably fast\n      expect(searchResponse.body.data.results.length).toBeGreaterThan(0);\n    });\n\n    it('Should handle malformed and edge case input data gracefully', async () => {\n      const edgeCaseInputs = [\n        // Null and undefined values\n        {\n          name: null,\n          description: undefined,\n          expectedError: 'VALIDATION_ERROR'\n        },\n        // Empty strings and whitespace\n        {\n          name: '',\n          description: '   \\n\\t   ',\n          expectedError: 'VALIDATION_ERROR'\n        },\n        // Unicode edge cases\n        {\n          name: '\uD83D\uDE00\uD83D\uDE01\uD83D\uDE02\uD83D\uDE03', // Emojis\n          description: '測試中文字符和日本語文字𝕌𝕟𝕚𝕔𝕠𝕕𝕖', // Mixed unicode\n          shouldSucceed: true\n        },\n        // Control characters\n        {\n          name: 'Test\\x00\\x01\\x02Campaign',\n          description: 'Description with\\r\\n\\tcontrol chars',\n          expectedSanitization: true\n        },\n        // Very long strings\n        {\n          name: 'A'.repeat(10000),\n          description: 'B'.repeat(100000),\n          expectedError: 'VALIDATION_ERROR'\n        },\n        // Special JSON characters\n        {\n          name: '\"Campaign\\\"with\\\"quotes\"',\n          description: '{\"malicious\": \"json\", \"injection\": true}',\n          shouldSucceed: true\n        },\n        // SQL injection patterns\n        {\n          name: \"'; DROP TABLE campaigns; --\",\n          description: \"' OR '1'='1' UNION SELECT * FROM users --\",\n          expectedSanitization: true\n        },\n        // XSS patterns\n        {\n          name: '<script>alert(\"xss\")</script>',\n          description: 'javascript:alert(1)//\\n\\r</title></style></textarea></script>',\n          expectedSanitization: true\n        },\n        // Path traversal\n        {\n          name: '../../../etc/passwd',\n          description: '..\\\\..\\\\..\\\\windows\\\\system32\\\\config\\\\sam',\n          expectedSanitization: true\n        },\n        // Binary data\n        {\n          name: Buffer.from([0x00, 0x01, 0x02, 0xFF]).toString(),\n          description: '\\x00\\xFF\\x7F\\x80',\n          expectedSanitization: true\n        },\n        // Invalid JSON structure simulation\n        {\n          name: 'Valid Name',\n          invalidField: { deeply: { nested: { invalid: { structure: 'test' } } } },\n          expectedError: 'VALIDATION_ERROR'\n        }\n      ];\n\n      for (const [index, input] of edgeCaseInputs.entries()) {\n        console.log(`Testing edge case ${index + 1}: ${input.name?.substring(0, 20)}...`);\n        \n        const response = await request(app)\n          .post('/api/campaigns')\n          .send({\n            id: `edge-case-${index}`,\n            ...input,\n            gmId: 'test-gm'\n          });\n\n        if (input.expectedError) {\n          expect(response.status).toBeGreaterThanOrEqual(400);\n          expect(response.body.error.code).toBe(input.expectedError);\n        } else if (input.shouldSucceed) {\n          expect(response.status).toBe(201);\n          expect(response.body.success).toBe(true);\n          \n          if (input.expectedSanitization) {\n            expect(response.body.data.name).not.toBe(input.name);\n            expect(response.body.metadata.sanitized).toBe(true);\n          }\n        }\n      }\n    });\n\n    it('Should handle timezone and date edge cases correctly', async () => {\n      const campaign = TestDataFactory.createTestCampaign();\n      await request(app).post('/api/campaigns').send(campaign).expect(201);\n\n      const dateEdgeCases = [\n        // Different timezone formats\n        { startTime: '2024-01-01T00:00:00.000Z', timezone: 'UTC' },\n        { startTime: '2024-01-01T00:00:00.000+09:00', timezone: 'JST' },\n        { startTime: '2024-01-01T00:00:00.000-08:00', timezone: 'PST' },\n        { startTime: '2024-01-01T00:00:00.000+05:30', timezone: 'IST' },\n        \n        // Edge dates\n        { startTime: '1970-01-01T00:00:00.000Z', edge: 'unix_epoch' },\n        { startTime: '2038-01-19T03:14:07.000Z', edge: 'y2038_problem' },\n        { startTime: '2000-02-29T00:00:00.000Z', edge: 'leap_year' },\n        { startTime: '2100-02-28T23:59:59.999Z', edge: 'non_leap_century' },\n        \n        // Daylight saving transitions\n        { startTime: '2024-03-10T07:00:00.000Z', edge: 'dst_start' },\n        { startTime: '2024-11-03T06:00:00.000Z', edge: 'dst_end' },\n        \n        // Invalid dates\n        { startTime: '2024-02-30T00:00:00.000Z', shouldFail: true },\n        { startTime: '2024-13-01T00:00:00.000Z', shouldFail: true },\n        { startTime: '2024-01-32T00:00:00.000Z', shouldFail: true },\n        { startTime: 'invalid-date-string', shouldFail: true },\n        { startTime: '2024-01-01T25:00:00.000Z', shouldFail: true }\n      ];\n\n      for (const testCase of dateEdgeCases) {\n        const session = TestDataFactory.createTestSession(campaign.id, {\n          name: `Session ${testCase.timezone || testCase.edge || 'invalid'}`,\n          startTime: new Date(testCase.startTime)\n        });\n\n        const response = await request(app)\n          .post('/api/sessions')\n          .send(session);\n\n        if (testCase.shouldFail) {\n          expect(response.status).toBeGreaterThanOrEqual(400);\n        } else {\n          expect(response.status).toBe(201);\n          expect(response.body.data.startTime).toBeDefined();\n          \n          // Verify date is normalized to ISO format\n          const returnedDate = new Date(response.body.data.startTime);\n          expect(returnedDate.toISOString()).toMatch(/^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}Z$/);\n        }\n      }\n    });\n\n    it('Should handle numeric edge cases and overflow conditions', async () {\n      const campaign = TestDataFactory.createTestCampaign();\n      await request(app).post('/api/campaigns').send(campaign).expect(201);\n\n      const numericEdgeCases = [\n        // Integer boundaries\n        { value: 2147483647, name: 'max_int32' }, // 2^31 - 1\n        { value: -2147483648, name: 'min_int32' }, // -2^31\n        { value: 9007199254740991, name: 'max_safe_integer' }, // Number.MAX_SAFE_INTEGER\n        { value: -9007199254740991, name: 'min_safe_integer' },\n        \n        // Float boundaries\n        { value: 1.7976931348623157e+308, name: 'max_float' }, // Number.MAX_VALUE\n        { value: 5e-324, name: 'min_positive_float' }, // Number.MIN_VALUE\n        { value: Number.POSITIVE_INFINITY, name: 'positive_infinity', shouldFail: true },\n        { value: Number.NEGATIVE_INFINITY, name: 'negative_infinity', shouldFail: true },\n        { value: NaN, name: 'not_a_number', shouldFail: true },\n        \n        // Zero variations\n        { value: 0, name: 'zero' },\n        { value: -0, name: 'negative_zero' },\n        { value: 0.0, name: 'float_zero' },\n        \n        // Very large numbers as strings\n        { value: '99999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999', name: 'giant_string_number', shouldFail: true },\n        \n        // Precision issues\n        { value: 0.1 + 0.2, name: 'float_precision' }, // 0.30000000000000004\n        { value: 1e-16, name: 'very_small_float' },\n        \n        // Scientific notation\n        { value: 1e10, name: 'scientific_positive' },\n        { value: 1e-10, name: 'scientific_negative' },\n        { value: 2.5e+20, name: 'large_scientific' }\n      ];\n\n      for (const testCase of numericEdgeCases) {\n        const character = TestDataFactory.createTestCharacter(campaign.id, {\n          name: `Numeric Test ${testCase.name}`,\n          stats: {\n            health: testCase.value,\n            maxHealth: testCase.value,\n            experience: testCase.value\n          }\n        });\n\n        const response = await request(app)\n          .post('/api/characters')\n          .send(character);\n\n        if (testCase.shouldFail) {\n          expect(response.status).toBeGreaterThanOrEqual(400);\n          expect(response.body.error.code).toMatch(/VALIDATION_ERROR|INVALID_NUMBER/);\n        } else {\n          expect(response.status).toBe(201);\n          expect(response.body.data.stats.health).toBeDefined();\n          \n          // Check for proper numeric handling\n          if (testCase.name === 'float_precision') {\n            // Should handle floating point precision issues\n            expect(response.body.data.stats.health).toBeCloseTo(0.3, 10);\n          }\n        }\n      }\n    });\n  });\n\n  describe('高負荷ストレステスト', () => {\n    it('Should handle concurrent user sessions without data corruption', async () => {\n      const campaign = TestDataFactory.createTestCampaign();\n      await request(app).post('/api/campaigns').send(campaign).expect(201);\n\n      const concurrentUsers = 100;\n      const operationsPerUser = 20;\n      \n      // Create concurrent user sessions\n      const userPromises = Array.from({ length: concurrentUsers }, async (_, userIndex) => {\n        const userId = `stress-user-${userIndex}`;\n        const operations = [];\n        \n        for (let op = 0; op < operationsPerUser; op++) {\n          const operationType = op % 4;\n          \n          switch (operationType) {\n            case 0: // Create character\n              operations.push(\n                request(app)\n                  .post('/api/characters')\n                  .send(TestDataFactory.createTestCharacter(campaign.id, {\n                    name: `${userId}-character-${op}`,\n                    playerId: userId\n                  }))\n              );\n              break;\n              \n            case 1: // Create location\n              operations.push(\n                request(app)\n                  .post('/api/locations')\n                  .send(TestDataFactory.createTestLocation(campaign.id, {\n                    name: `${userId}-location-${op}`,\n                    createdBy: userId\n                  }))\n              );\n              break;\n              \n            case 2: // Create session\n              operations.push(\n                request(app)\n                  .post('/api/sessions')\n                  .send(TestDataFactory.createTestSession(campaign.id, {\n                    name: `${userId}-session-${op}`,\n                    gmId: userId\n                  }))\n              );\n              break;\n              \n            case 3: // Query data\n              operations.push(\n                request(app)\n                  .get(`/api/characters?campaignId=${campaign.id}&playerId=${userId}`)\n              );\n              break;\n          }\n        }\n        \n        return Promise.allSettled(operations);\n      });\n\n      const startTime = performance.now();\n      const allResults = await Promise.all(userPromises);\n      const totalTime = performance.now() - startTime;\n\n      console.log(`Concurrent stress test completed in ${totalTime.toFixed(2)}ms`);\n      \n      // Analyze results\n      let totalOperations = 0;\n      let successfulOperations = 0;\n      let errors = [];\n      \n      allResults.forEach((userResults, userIndex) => {\n        userResults.forEach((result, opIndex) => {\n          totalOperations++;\n          if (result.status === 'fulfilled' && result.value.status < 400) {\n            successfulOperations++;\n          } else {\n            errors.push({\n              user: userIndex,\n              operation: opIndex,\n              error: result.status === 'fulfilled' ? result.value.body : result.reason\n            });\n          }\n        });\n      });\n      \n      const successRate = successfulOperations / totalOperations;\n      console.log(`Success rate: ${(successRate * 100).toFixed(2)}% (${successfulOperations}/${totalOperations})`);\n      \n      expect(successRate).toBeGreaterThan(0.95); // 95% success rate minimum\n      expect(totalTime).toBeLessThan(60000); // Should complete within 1 minute\n      \n      // Check data integrity\n      const charactersResponse = await request(app)\n        .get(`/api/characters?campaignId=${campaign.id}`)\n        .expect(200);\n      \n      const locationsResponse = await request(app)\n        .get(`/api/locations?campaignId=${campaign.id}`)\n        .expect(200);\n      \n      const sessionsResponse = await request(app)\n        .get(`/api/sessions?campaignId=${campaign.id}`)\n        .expect(200);\n      \n      // Verify no duplicate IDs (data corruption check)\n      const characterIds = charactersResponse.body.data.map((c: any) => c.id);\n      const uniqueCharacterIds = [...new Set(characterIds)];\n      expect(uniqueCharacterIds.length).toBe(characterIds.length);\n      \n      const locationIds = locationsResponse.body.data.map((l: any) => l.id);\n      const uniqueLocationIds = [...new Set(locationIds)];\n      expect(uniqueLocationIds.length).toBe(locationIds.length);\n    });\n\n    it('Should handle memory pressure and garbage collection efficiently', async () => {\n      // Monitor initial memory usage\n      const initialMemory = process.memoryUsage();\n      console.log('Initial memory:', initialMemory);\n      \n      const campaign = TestDataFactory.createTestCampaign();\n      await request(app).post('/api/campaigns').send(campaign).expect(201);\n\n      // Create memory-intensive operations\n      const memoryIntensiveOperations = [];\n      \n      for (let i = 0; i < 500; i++) {\n        // Create large objects\n        const largeCharacter = TestDataFactory.createTestCharacter(campaign.id, {\n          name: `Memory Test Character ${i}`,\n          description: 'Large description: ' + 'x'.repeat(10000),\n          stats: {\n            detailedHistory: Array.from({ length: 1000 }, (_, j) => ({\n              event: `Event ${j}`,\n              details: 'Event details: ' + 'y'.repeat(1000)\n            })),\n            largeInventory: Array.from({ length: 500 }, (_, j) => ({\n              item: `Item ${j}`,\n              description: 'Item description: ' + 'z'.repeat(200)\n            }))\n          }\n        });\n        \n        memoryIntensiveOperations.push(\n          request(app)\n            .post('/api/characters')\n            .send(largeCharacter)\n        );\n        \n        // Trigger garbage collection periodically\n        if (i % 100 === 0 && global.gc) {\n          global.gc();\n          const currentMemory = process.memoryUsage();\n          console.log(`Memory at iteration ${i}:`, currentMemory);\n          \n          // Memory should not grow unbounded\n          const memoryIncrease = currentMemory.heapUsed - initialMemory.heapUsed;\n          expect(memoryIncrease).toBeLessThan(500 * 1024 * 1024); // Less than 500MB increase\n        }\n      }\n      \n      // Execute operations in batches to control memory\n      const batchSize = 50;\n      for (let i = 0; i < memoryIntensiveOperations.length; i += batchSize) {\n        const batch = memoryIntensiveOperations.slice(i, i + batchSize);\n        await Promise.allSettled(batch);\n        \n        // Force garbage collection after each batch\n        if (global.gc) {\n          global.gc();\n        }\n        \n        // Small delay to allow GC\n        await new Promise(resolve => setTimeout(resolve, 100));\n      }\n      \n      const finalMemory = process.memoryUsage();\n      console.log('Final memory:', finalMemory);\n      \n      // Memory increase should be reasonable\n      const totalMemoryIncrease = finalMemory.heapUsed - initialMemory.heapUsed;\n      expect(totalMemoryIncrease).toBeLessThan(1024 * 1024 * 1024); // Less than 1GB\n      \n      // Verify operations completed successfully\n      const charactersResponse = await request(app)\n        .get(`/api/characters/count?campaignId=${campaign.id}`)\n        .expect(200);\n      \n      expect(charactersResponse.body.data.count).toBe(500);\n    });\n\n    it('Should handle database lock contention and deadlock scenarios', async () => {\n      const campaign = TestDataFactory.createTestCampaign();\n      await request(app).post('/api/campaigns').send(campaign).expect(201);\n\n      // Create scenarios that could cause database locks\n      const lockContentionTests = [\n        // Concurrent updates to same entity\n        {\n          name: 'concurrent_updates',\n          operations: Array.from({ length: 50 }, (_, i) => () =>\n            request(app)\n              .patch(`/api/campaigns/${campaign.id}`)\n              .send({ description: `Updated description ${i}` })\n          )\n        },\n        \n        // Concurrent reads and writes\n        {\n          name: 'read_write_mix',\n          operations: Array.from({ length: 100 }, (_, i) => {\n            if (i % 2 === 0) {\n              return () => request(app)\n                .post('/api/characters')\n                .send(TestDataFactory.createTestCharacter(campaign.id, { name: `Character ${i}` }));\n            } else {\n              return () => request(app)\n                .get(`/api/characters?campaignId=${campaign.id}`);\n            }\n          })\n        },\n        \n        // Circular dependency scenario\n        {\n          name: 'circular_dependencies',\n          operations: Array.from({ length: 20 }, (_, i) => {\n            const char1Id = `char-${i}-1`;\n            const char2Id = `char-${i}-2`;\n            \n            return () => Promise.all([\n              request(app)\n                .post('/api/characters')\n                .send(TestDataFactory.createTestCharacter(campaign.id, {\n                  id: char1Id,\n                  name: `Character ${i}-1`,\n                  relationships: [{ targetId: char2Id, type: 'ally' }]\n                })),\n              request(app)\n                .post('/api/characters')\n                .send(TestDataFactory.createTestCharacter(campaign.id, {\n                  id: char2Id,\n                  name: `Character ${i}-2`,\n                  relationships: [{ targetId: char1Id, type: 'ally' }]\n                }))\n            ]);\n          })\n        }\n      ];\n\n      for (const test of lockContentionTests) {\n        console.log(`Running lock contention test: ${test.name}`);\n        \n        const startTime = performance.now();\n        const results = await Promise.allSettled(\n          test.operations.map(op => op())\n        );\n        const testTime = performance.now() - startTime;\n        \n        console.log(`${test.name} completed in ${testTime.toFixed(2)}ms`);\n        \n        // Analyze results\n        const successful = results.filter(r => \n          r.status === 'fulfilled' && \n          (Array.isArray(r.value) ? \n            r.value.every(v => v.status < 400) : \n            r.value.status < 400\n          )\n        ).length;\n        \n        const deadlocks = results.filter(r => \n          r.status === 'rejected' || \n          (r.status === 'fulfilled' && \n           (Array.isArray(r.value) ? \n             r.value.some(v => v.body?.error?.code === 'DATABASE_DEADLOCK') :\n             r.value.body?.error?.code === 'DATABASE_DEADLOCK'\n           )\n          )\n        ).length;\n        \n        console.log(`${test.name}: ${successful}/${results.length} successful, ${deadlocks} deadlocks`);\n        \n        // Should handle deadlocks gracefully\n        expect(successful).toBeGreaterThan(results.length * 0.8); // 80% success rate\n        expect(testTime).toBeLessThan(30000); // Should not hang indefinitely\n      }\n      \n      // Verify database integrity after contention tests\n      const integrityCheck = await request(app)\n        .get(`/api/admin/database/integrity-check?campaignId=${campaign.id}`)\n        .expect(200);\n      \n      expect(integrityCheck.body.data.issues).toHaveLength(0);\n    });\n  });\n\n  describe('ネットワーク障害とタイムアウトシナリオ', () => {\n    it('Should handle network timeouts and partial responses gracefully', async () => {\n      // Configure network failure scenarios\n      mockServices.network.setScenarios([\n        'timeout',\n        'partial_response',\n        'connection_reset',\n        'slow_response'\n      ]);\n\n      const campaign = TestDataFactory.createTestCampaign();\n      await request(app).post('/api/campaigns').send(campaign).expect(201);\n\n      const networkStressTests = [\n        {\n          name: 'ai_request_with_timeout',\n          request: () => request(app)\n            .post('/api/ai-agent/character/generate')\n            .timeout(5000)\n            .send({\n              provider: 'openai',\n              apiKey: 'test-api-key',\n              characterType: 'NPC',\n              characterBasics: { name: 'Test Character' },\n              campaignContext: { campaignId: campaign.id }\n            })\n        },\n        {\n          name: 'large_data_upload',\n          request: () => request(app)\n            .post('/api/campaigns')\n            .timeout(10000)\n            .send({\n              ...TestDataFactory.createTestCampaign(),\n              largeData: 'x'.repeat(1000000) // 1MB of data\n            })\n        },\n        {\n          name: 'concurrent_timeouts',\n          request: () => Promise.allSettled(\n            Array.from({ length: 10 }, () =>\n              request(app)\n                .get(`/api/characters?campaignId=${campaign.id}&timeout=1000`)\n                .timeout(2000)\n            )\n          )\n        }\n      ];\n\n      for (const test of networkStressTests) {\n        console.log(`Running network test: ${test.name}`);\n        \n        const startTime = performance.now();\n        try {\n          const result = await test.request();\n          const testTime = performance.now() - startTime;\n          \n          console.log(`${test.name} completed in ${testTime.toFixed(2)}ms`);\n          \n          // Should either succeed or fail gracefully\n          if (Array.isArray(result)) {\n            // For concurrent tests\n            const timeouts = result.filter(r => \n              r.status === 'rejected' && \n              r.reason.code === 'ECONNABORTED'\n            ).length;\n            console.log(`${test.name}: ${timeouts}/${result.length} timeouts`);\n          } else {\n            // Single request\n            expect(result.status).toBeDefined();\n          }\n          \n        } catch (error: any) {\n          const testTime = performance.now() - startTime;\n          console.log(`${test.name} failed in ${testTime.toFixed(2)}ms:`, error.code);\n          \n          // Timeout should be handled gracefully\n          if (error.code === 'ECONNABORTED') {\n            expect(testTime).toBeGreaterThan(1000); // Should respect timeout\n          }\n        }\n      }\n    });\n\n    it('Should recover from temporary service outages', async () => {\n      const campaign = TestDataFactory.createTestCampaign();\n      await request(app).post('/api/campaigns').send(campaign).expect(201);\n\n      // Simulate service outage\n      mockServices.setGlobalOutage(true);\n      \n      // Requests during outage should fail appropriately\n      const outageResponse = await request(app)\n        .post('/api/characters')\n        .send(TestDataFactory.createTestCharacter(campaign.id))\n        .expect(503);\n      \n      expect(outageResponse.body.error.code).toBe('SERVICE_UNAVAILABLE');\n      expect(outageResponse.body.error.retryAfter).toBeDefined();\n      \n      // Simulate partial recovery\n      mockServices.setGlobalOutage(false);\n      mockServices.setDegradedPerformance(true);\n      \n      const recoveryStartTime = performance.now();\n      const recoveryResponse = await request(app)\n        .post('/api/characters')\n        .send(TestDataFactory.createTestCharacter(campaign.id, { name: 'Recovery Test' }))\n        .expect(201);\n      const recoveryTime = performance.now() - recoveryStartTime;\n      \n      expect(recoveryResponse.body.success).toBe(true);\n      expect(recoveryTime).toBeGreaterThan(1000); // Should be slower during degraded performance\n      expect(recoveryResponse.headers['x-service-status']).toBe('degraded');\n      \n      // Full recovery\n      mockServices.setDegradedPerformance(false);\n      \n      const fullRecoveryResponse = await request(app)\n        .get(`/api/characters?campaignId=${campaign.id}`)\n        .expect(200);\n      \n      expect(fullRecoveryResponse.body.data.length).toBeGreaterThan(0);\n      expect(fullRecoveryResponse.headers['x-service-status']).toBeUndefined();\n    });\n  });\n\n  describe('セキュリティストレステスト', () => {\n    it('Should resist various attack patterns under load', async () => {\n      const attackPatterns = [\n        {\n          name: 'sql_injection_flood',\n          requests: Array.from({ length: 100 }, (_, i) => () =>\n            request(app)\n              .get('/api/campaigns/search')\n              .query({ q: `'; DROP TABLE campaigns; SELECT '${i}` })\n          )\n        },\n        {\n          name: 'xss_attempt_flood',\n          requests: Array.from({ length: 100 }, (_, i) => () =>\n            request(app)\n              .post('/api/campaigns')\n              .send({\n                name: `<script>alert('xss${i}')</script>`,\n                description: `javascript:alert(${i})`\n              })\n          )\n        },\n        {\n          name: 'path_traversal_flood',\n          requests: Array.from({ length: 100 }, (_, i) => () =>\n            request(app)\n              .get(`/api/campaigns/../../../etc/passwd?t=${i}`)\n          )\n        },\n        {\n          name: 'oversized_request_flood',\n          requests: Array.from({ length: 50 }, (_, i) => () =>\n            request(app)\n              .post('/api/campaigns')\n              .send({\n                name: `Oversized ${i}`,\n                description: 'x'.repeat(1000000), // 1MB\n                maliciousData: Array.from({ length: 10000 }, () => ({ evil: 'data' }))\n              })\n          )\n        }\n      ];\n\n      for (const pattern of attackPatterns) {\n        console.log(`Testing security against: ${pattern.name}`);\n        \n        const startTime = performance.now();\n        const results = await Promise.allSettled(\n          pattern.requests.map(req => req())\n        );\n        const testTime = performance.now() - startTime;\n        \n        // Analyze security response\n        const blocked = results.filter(r => \n          r.status === 'fulfilled' && \n          [400, 403, 413, 429].includes(r.value.status)\n        ).length;\n        \n        const rateLimited = results.filter(r => \n          r.status === 'fulfilled' && r.value.status === 429\n        ).length;\n        \n        console.log(`${pattern.name}: ${blocked}/${results.length} blocked, ${rateLimited} rate limited`);\n        \n        // Should block most attacks\n        expect(blocked).toBeGreaterThan(results.length * 0.8);\n        // Should activate rate limiting\n        expect(rateLimited).toBeGreaterThan(0);\n        // Should not crash or hang\n        expect(testTime).toBeLessThan(30000);\n      }\n      \n      // Verify system is still functional after attacks\n      const healthCheck = await request(app)\n        .get('/api/health')\n        .expect(200);\n      \n      expect(healthCheck.body.status).toBe('healthy');\n    });\n  });\n\n  describe('プラットフォーム互換性テスト', () => {\n    it('Should handle different client environments and capabilities', async () => {\n      const campaign = TestDataFactory.createTestCampaign();\n      await request(app).post('/api/campaigns').send(campaign).expect(201);\n\n      const clientEnvironments = [\n        {\n          name: 'modern_browser',\n          headers: {\n            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 Chrome/120.0.0.0',\n            'Accept': 'application/json',\n            'Accept-Encoding': 'gzip, deflate, br'\n          },\n          capabilities: ['websockets', 'webgl', 'webassembly']\n        },\n        {\n          name: 'legacy_browser',\n          headers: {\n            'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; rv:11.0) like Gecko',\n            'Accept': 'application/json',\n            'Accept-Encoding': 'gzip, deflate'\n          },\n          capabilities: ['limited_websockets']\n        },\n        {\n          name: 'mobile_device',\n          headers: {\n            'User-Agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 17_0 like Mac OS X) AppleWebKit/605.1.15 Mobile/15E148',\n            'Accept': 'application/json',\n            'Connection': 'keep-alive'\n          },\n          capabilities: ['touch', 'orientation', 'limited_memory']\n        },\n        {\n          name: 'api_client',\n          headers: {\n            'User-Agent': 'TRPGBot/1.0',\n            'Accept': 'application/json',\n            'Content-Type': 'application/json'\n          },\n          capabilities: ['programmatic']\n        }\n      ];\n\n      for (const env of clientEnvironments) {\n        console.log(`Testing client environment: ${env.name}`);\n        \n        // Test basic operations with environment-specific headers\n        const createResponse = await request(app)\n          .post('/api/characters')\n          .set(env.headers)\n          .send(TestDataFactory.createTestCharacter(campaign.id, {\n            name: `Character from ${env.name}`\n          }))\n          .expect(201);\n        \n        expect(createResponse.body.success).toBe(true);\n        \n        // Verify response is adapted to client capabilities\n        if (env.capabilities.includes('limited_memory')) {\n          expect(createResponse.body.metadata.optimizedForMobile).toBe(true);\n        }\n        \n        if (env.capabilities.includes('programmatic')) {\n          expect(createResponse.body.metadata.apiVersion).toBeDefined();\n        }\n        \n        // Test feature availability based on capabilities\n        const featureResponse = await request(app)\n          .get('/api/features/available')\n          .set(env.headers)\n          .expect(200);\n        \n        if (env.capabilities.includes('websockets')) {\n          expect(featureResponse.body.data.realtime).toBe(true);\n        }\n        \n        if (env.capabilities.includes('webgl')) {\n          expect(featureResponse.body.data.advanced3d).toBe(true);\n        }\n      }\n    });\n  });\n});\n\n// Utility function for stress testing with workers\nfunction runWorkerStressTest(workerScript: string, workerData: any): Promise<any> {\n  return new Promise((resolve, reject) => {\n    const worker = new Worker(workerScript, { workerData });\n    \n    worker.on('message', resolve);\n    worker.on('error', reject);\n    worker.on('exit', (code) => {\n      if (code !== 0) {\n        reject(new Error(`Worker stopped with exit code ${code}`));\n      }\n    });\n  });\n}"